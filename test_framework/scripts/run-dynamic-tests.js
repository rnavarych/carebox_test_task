#!/usr/bin/env node

/**
 * Dynamic Playwright Test Runner
 *
 * Executes test cases generated by TestGeneratorAgent.
 * No hardcoded tests - everything is driven by the generated test-cases.json
 */

import fs from 'fs/promises';
import fsSync from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { chromium } from 'playwright';
import pixelmatch from 'pixelmatch';
import { PNG } from 'pngjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const COMPILED_DIR = path.join(__dirname, '../output/compiled');
const SCREENSHOTS_DIR = path.join(__dirname, '../output/screenshots');
const DIFF_DIR = path.join(__dirname, '../output/diffs');
const RESULTS_DIR = path.join(__dirname, '../output/test-results');
const GENERATED_TESTS_DIR = path.join(__dirname, '../output/generated-tests');
const TEST_CASES_FILE = path.join(GENERATED_TESTS_DIR, 'test-cases.json');

class DynamicTestRunner {
  constructor() {
    this.browser = null;
    this.context = null;
    this.testCases = null;
    this.results = {
      timestamp: new Date().toISOString(),
      testPlanId: null,
      mode: 'regression',
      totalTests: 0,
      passed: 0,
      failed: 0,
      skipped: 0,
      testCases: []
    };
  }

  log(message) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }

  async initialize() {
    this.log('Initializing Dynamic Test Runner...');
    this.browser = await chromium.launch({ headless: true });
    this.context = await this.browser.newContext();

    await fs.mkdir(SCREENSHOTS_DIR, { recursive: true });
    await fs.mkdir(DIFF_DIR, { recursive: true });
    await fs.mkdir(RESULTS_DIR, { recursive: true });
  }

  async cleanup() {
    if (this.context) await this.context.close();
    if (this.browser) await this.browser.close();
  }

  async loadTestCases() {
    this.log(`Loading test cases from: ${TEST_CASES_FILE}`);

    try {
      const content = await fs.readFile(TEST_CASES_FILE, 'utf-8');
      this.testCases = JSON.parse(content);
      this.results.testPlanId = this.testCases.testPlanId;
      this.log(`Loaded ${this.testCases.testCases?.length || 0} test cases`);
      return true;
    } catch (error) {
      this.log(`ERROR: Failed to load test cases: ${error.message}`);
      return false;
    }
  }

  async loadTemplate(templateName) {
    const htmlPath = path.join(COMPILED_DIR, `${templateName}.html`);
    return await fs.readFile(htmlPath, 'utf-8');
  }

  // ============================================================================
  // ASSERTION EXECUTORS
  // ============================================================================

  async executeAssertion(assertion, testCase, page) {
    const { type } = assertion;

    try {
      switch (type) {
        case 'html_exists':
          return await this.assertHtmlExists(testCase.template);
        case 'has_doctype':
          return await this.assertHasDoctype(testCase.template);
        case 'has_html_tag':
          return await this.assertHasTag(testCase.template, '<html');
        case 'has_body_tag':
          return await this.assertHasTag(testCase.template, '<body');
        case 'has_head_tag':
          return await this.assertHasTag(testCase.template, '<head');
        case 'no_ejs_tags':
          return await this.assertNoEjsTags(testCase.template);
        case 'color_matches':
          return await this.assertColorMatches(testCase.template, assertion.expected);
        case 'color_absent':
          return await this.assertColorAbsent(testCase.template, assertion.forbidden);
        case 'content_contains':
          return await this.assertContentContains(testCase.template, assertion.expected, page);
        case 'content_absent':
          return await this.assertContentAbsent(testCase.template, assertion.forbidden, page);
        case 'visual_match':
          return await this.assertVisualMatch(testCase.template, assertion.baseTemplate, assertion.threshold, page);
        case 'size_under':
          return await this.assertSizeUnder(testCase.template, assertion.maxKb || 100);
        case 'ejs_rendered':
          return await this.assertEjsRendered(testCase.template, page);
        case 'structure_valid':
          return await this.assertStructureValid(testCase.template);
        default:
          return { passed: false, message: `Unknown assertion type: ${type}` };
      }
    } catch (error) {
      return { passed: false, message: `Error: ${error.message}` };
    }
  }

  async assertHtmlExists(template) {
    try {
      const html = await this.loadTemplate(template);
      const passed = html && html.length > 0;
      return {
        passed,
        message: passed ? `Loaded ${html.length} bytes` : 'Template empty or missing'
      };
    } catch (error) {
      return { passed: false, message: `Failed to load: ${error.message}` };
    }
  }

  async assertHasDoctype(template) {
    const html = await this.loadTemplate(template);
    const passed = html.toLowerCase().includes('<!doctype');
    return {
      passed,
      message: passed ? 'DOCTYPE found' : 'REGRESSION FAILURE: Missing DOCTYPE'
    };
  }

  async assertHasTag(template, tag) {
    const html = await this.loadTemplate(template);
    const passed = html.toLowerCase().includes(tag.toLowerCase());
    return {
      passed,
      message: passed ? `${tag}> tag found` : `REGRESSION FAILURE: Missing ${tag}> tag`
    };
  }

  async assertNoEjsTags(template) {
    const html = await this.loadTemplate(template);
    const hasEjs = html.includes('<%') || html.includes('%>');
    return {
      passed: !hasEjs,
      message: hasEjs ? 'REGRESSION FAILURE: Unresolved EJS tags found' : 'All EJS resolved'
    };
  }

  async assertColorMatches(template, expectedColor) {
    const html = await this.loadTemplate(template);
    const passed = html.toLowerCase().includes(expectedColor.toLowerCase());
    return {
      passed,
      message: passed
        ? `✓ Found color ${expectedColor}`
        : `REGRESSION FAILURE: Missing required color ${expectedColor}`
    };
  }

  async assertColorAbsent(template, forbiddenColor) {
    const html = await this.loadTemplate(template);
    const hasForbidden = html.toLowerCase().includes(forbiddenColor.toLowerCase());
    return {
      passed: !hasForbidden,
      message: hasForbidden
        ? `REGRESSION FAILURE: Found forbidden color ${forbiddenColor}`
        : `✓ No forbidden color ${forbiddenColor}`
    };
  }

  async assertContentContains(template, expected, page) {
    const html = await this.loadTemplate(template);
    await page.setContent(html, { waitUntil: 'networkidle' });
    const bodyText = await page.evaluate(() => document.body.innerText.toLowerCase());
    const passed = bodyText.includes(expected.toLowerCase());
    return {
      passed,
      message: passed
        ? `✓ Found "${expected}"`
        : `REGRESSION FAILURE: Missing required content "${expected}"`
    };
  }

  async assertContentAbsent(template, forbidden, page) {
    const html = await this.loadTemplate(template);
    await page.setContent(html, { waitUntil: 'networkidle' });
    const bodyText = await page.evaluate(() => document.body.innerText.toLowerCase());
    const hasForbidden = bodyText.includes(forbidden.toLowerCase());
    return {
      passed: !hasForbidden,
      message: hasForbidden
        ? `REGRESSION FAILURE: Found forbidden content "${forbidden}"`
        : `✓ No forbidden content "${forbidden}"`
    };
  }

  async assertEjsRendered(template, page) {
    const html = await this.loadTemplate(template);
    await page.setContent(html, { waitUntil: 'networkidle' });
    const bodyText = await page.evaluate(() => document.body.innerText);
    // Check for common personalization markers
    const hasPersonalization = bodyText.includes('John') ||
                               bodyText.includes('Carebox') ||
                               bodyText.includes('Valued Visitor');
    return {
      passed: hasPersonalization,
      message: hasPersonalization
        ? '✓ EJS variables rendered'
        : 'REGRESSION FAILURE: EJS variables not rendered'
    };
  }

  async assertSizeUnder(template, maxKb) {
    const html = await this.loadTemplate(template);
    const sizeKb = Buffer.byteLength(html, 'utf-8') / 1024;
    const passed = sizeKb < maxKb;
    return {
      passed,
      message: passed
        ? `✓ ${sizeKb.toFixed(1)}KB (under ${maxKb}KB)`
        : `REGRESSION FAILURE: ${sizeKb.toFixed(1)}KB exceeds ${maxKb}KB`
    };
  }

  async assertStructureValid(template) {
    try {
      const html = await this.loadTemplate(template);
      const hasDoctype = html.toLowerCase().includes('<!doctype');
      const hasHtml = html.includes('<html');
      const hasHead = html.includes('<head');
      const hasBody = html.includes('<body');
      const isValid = hasDoctype && hasHtml && hasHead && hasBody;

      return {
        passed: isValid,
        message: isValid
          ? '✓ Valid HTML structure (DOCTYPE, HTML, HEAD, BODY)'
          : `REGRESSION FAILURE: Invalid structure - missing ${!hasDoctype ? 'DOCTYPE ' : ''}${!hasHtml ? 'HTML ' : ''}${!hasHead ? 'HEAD ' : ''}${!hasBody ? 'BODY' : ''}`
      };
    } catch (error) {
      return { passed: false, message: `Error: ${error.message}` };
    }
  }

  async assertVisualMatch(template, baseTemplate, threshold, page) {
    // Capture base screenshot
    const baseHtml = await this.loadTemplate(baseTemplate);
    await page.setViewportSize({ width: 800, height: 600 });
    await page.setContent(baseHtml, { waitUntil: 'networkidle' });
    const basePath = path.join(SCREENSHOTS_DIR, `visual-${baseTemplate}.png`);
    await page.screenshot({ path: basePath, fullPage: true });

    // Capture comparison screenshot
    const compareHtml = await this.loadTemplate(template);
    await page.setContent(compareHtml, { waitUntil: 'networkidle' });
    const comparePath = path.join(SCREENSHOTS_DIR, `visual-${template}.png`);
    await page.screenshot({ path: comparePath, fullPage: true });

    // Compare
    const diffResult = await this.compareScreenshots(basePath, comparePath, template);
    const passed = diffResult.diffPercentage <= threshold;

    return {
      passed,
      message: passed
        ? `✓ Visual diff ${diffResult.diffPercentage.toFixed(2)}% within ${threshold}%`
        : `REGRESSION FAILURE: Visual diff ${diffResult.diffPercentage.toFixed(2)}% exceeds ${threshold}%`,
      screenshots: {
        base: path.basename(basePath),
        compare: path.basename(comparePath),
        diff: path.basename(diffResult.diffPath),
        comparison: path.basename(diffResult.sideBySidePath),
        diffPercentage: diffResult.diffPercentage.toFixed(2)
      }
    };
  }

  async compareScreenshots(basePath, comparePath, name) {
    const baseImg = PNG.sync.read(fsSync.readFileSync(basePath));
    const compareImg = PNG.sync.read(fsSync.readFileSync(comparePath));

    const width = Math.max(baseImg.width, compareImg.width);
    const height = Math.max(baseImg.height, compareImg.height);
    const diff = new PNG({ width, height });

    const baseData = this.padImage(baseImg, width, height);
    const compareData = this.padImage(compareImg, width, height);

    const numDiffPixels = pixelmatch(baseData, compareData, diff.data, width, height, {
      threshold: 0.1,
      includeAA: true,
      diffColor: [255, 0, 128],
      diffColorAlt: [255, 255, 0],
      alpha: 0.1
    });

    const totalPixels = width * height;
    const diffPercentage = (numDiffPixels / totalPixels) * 100;

    // Save diff image
    const diffPath = path.join(DIFF_DIR, `diff-${name}.png`);
    fsSync.writeFileSync(diffPath, PNG.sync.write(diff));

    // Create side-by-side comparison
    const sideBySidePath = await this.createSideBySide(baseImg, compareImg, diff, name, width, height);

    return { diffPercentage, diffPath, sideBySidePath };
  }

  padImage(img, targetWidth, targetHeight) {
    if (img.width === targetWidth && img.height === targetHeight) {
      return img.data;
    }
    const paddedData = Buffer.alloc(targetWidth * targetHeight * 4, 255);
    for (let y = 0; y < img.height; y++) {
      for (let x = 0; x < img.width; x++) {
        const srcIdx = (y * img.width + x) * 4;
        const dstIdx = (y * targetWidth + x) * 4;
        paddedData[dstIdx] = img.data[srcIdx];
        paddedData[dstIdx + 1] = img.data[srcIdx + 1];
        paddedData[dstIdx + 2] = img.data[srcIdx + 2];
        paddedData[dstIdx + 3] = img.data[srcIdx + 3];
      }
    }
    return paddedData;
  }

  async createSideBySide(baseImg, compareImg, diffImg, name, width, height) {
    const padding = 10;
    const totalWidth = (width * 3) + (padding * 4);
    const totalHeight = height + (padding * 2);
    const sideBySide = new PNG({ width: totalWidth, height: totalHeight });

    // Fill white background
    for (let i = 0; i < sideBySide.data.length; i += 4) {
      sideBySide.data[i] = sideBySide.data[i + 1] = sideBySide.data[i + 2] = sideBySide.data[i + 3] = 255;
    }

    // Copy images
    this.copyImage(sideBySide, baseImg, padding, padding);
    this.copyImage(sideBySide, compareImg, width + padding * 2, padding);
    this.copyImage(sideBySide, diffImg, width * 2 + padding * 3, padding);

    const sideBySidePath = path.join(DIFF_DIR, `comparison-${name}.png`);
    fsSync.writeFileSync(sideBySidePath, PNG.sync.write(sideBySide));
    return sideBySidePath;
  }

  copyImage(dest, src, offsetX, offsetY) {
    for (let y = 0; y < src.height; y++) {
      for (let x = 0; x < src.width; x++) {
        const srcIdx = (y * src.width + x) * 4;
        const destIdx = ((y + offsetY) * dest.width + (x + offsetX)) * 4;
        if (destIdx >= 0 && destIdx < dest.data.length - 3) {
          dest.data[destIdx] = src.data[srcIdx];
          dest.data[destIdx + 1] = src.data[srcIdx + 1];
          dest.data[destIdx + 2] = src.data[srcIdx + 2];
          dest.data[destIdx + 3] = src.data[srcIdx + 3];
        }
      }
    }
  }

  // ============================================================================
  // TEST EXECUTION
  // ============================================================================

  async runTests() {
    if (!this.testCases?.testCases?.length) {
      this.log('ERROR: No test cases to execute');
      return this.results;
    }

    this.log(`\n${'═'.repeat(60)}`);
    this.log('Dynamic Playwright Test Runner - REGRESSION MODE');
    this.log('Tests generated by AI - All templates must match base');
    this.log(`${'═'.repeat(60)}\n`);

    const page = await this.context.newPage();

    for (const testCase of this.testCases.testCases) {
      this.log(`\nRunning: [${testCase.id}] ${testCase.name}`);
      const startTime = Date.now();

      const result = {
        id: testCase.id,
        name: testCase.name,
        description: testCase.description,
        suite: testCase.suite,
        priority: testCase.priority,
        type: testCase.type,
        template: testCase.template,
        status: 'pending',
        assertions: [],
        duration: 0
      };

      let allPassed = true;

      for (const assertion of testCase.assertions) {
        const assertionResult = await this.executeAssertion(assertion, testCase, page);
        result.assertions.push({
          name: assertion.description || assertion.type,
          type: assertion.type,
          passed: assertionResult.passed,
          message: assertionResult.message,
          screenshots: assertionResult.screenshots
        });

        if (!assertionResult.passed) {
          allPassed = false;
        }
      }

      result.status = allPassed ? 'passed' : 'failed';
      result.duration = Date.now() - startTime;

      this.results.testCases.push(result);
      this.results.totalTests++;

      if (allPassed) {
        this.results.passed++;
        this.log(`  ✅ PASSED (${result.duration}ms)`);
      } else {
        this.results.failed++;
        this.log(`  ❌ FAILED (${result.duration}ms)`);
      }

      // Log assertions
      for (const a of result.assertions) {
        const icon = a.passed ? '✓' : '✗';
        this.log(`     ${icon} ${a.name}: ${a.message}`);
      }
    }

    await page.close();

    // Summary
    this.log(`\n${'═'.repeat(60)}`);
    this.log('Test Results Summary');
    this.log(`${'═'.repeat(60)}`);
    this.log(`Total: ${this.results.totalTests} | Passed: ${this.results.passed} ✅ | Failed: ${this.results.failed} ❌`);
    this.log(`Pass Rate: ${((this.results.passed / this.results.totalTests) * 100).toFixed(1)}%`);

    if (this.results.failed > 0) {
      this.log(`\n⚠️ REGRESSION FAILURES DETECTED:`);
      for (const tc of this.results.testCases.filter(t => t.status === 'failed')) {
        this.log(`  ❌ [${tc.id}] ${tc.name}`);
        for (const a of tc.assertions.filter(a => !a.passed)) {
          this.log(`      → ${a.message}`);
        }
      }
    }

    return this.results;
  }

  async run() {
    try {
      await this.initialize();

      if (!await this.loadTestCases()) {
        this.log('ERROR: Cannot run without test cases');
        return { ...this.results, error: 'No test cases found' };
      }

      await this.runTests();

      // Save results
      const resultsPath = path.join(RESULTS_DIR, `playwright-results-${Date.now()}.json`);
      await fs.writeFile(resultsPath, JSON.stringify(this.results, null, 2));
      this.log(`\nResults saved: ${resultsPath}`);

      return this.results;
    } finally {
      await this.cleanup();
    }
  }
}

// Main execution
const runner = new DynamicTestRunner();
runner.run()
  .then(results => {
    process.exit(results.failed > 0 ? 1 : 0);
  })
  .catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });

export { DynamicTestRunner };
